/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package com.datamelt.util;

import java.io.FileInputStream;
import java.lang.annotation.Annotation;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Properties;

import com.datamelt.util.CheckMethodAnnotation;
import com.datamelt.rules.implementation.GenericCheck;

/**
 * Utility class to generate SQL insert statements from the methods of a Check class.
 * 
 * The methods of a Check class are used as meta data in the database to define business
 * rules in the Business Rules Maintenance Tool - a web application.
 * 
 * The SQL statement is generated by retrieving the checkId and the method annotations
 * from the relevant Check class. Only the "evaluate" methods of the Check class are used.
 * 
 * This avoids to manually maintain the database records for the Business Rules Maintenance
 * tool in synch with the code.
 * 
 *  @author uwe geercken
 *  
 */
public class CheckDatabaseRecordGenerator
{
	public static void main(String[] args) throws Exception
	{
		CheckDatabaseRecordGenerator generator = new CheckDatabaseRecordGenerator();
		
		Properties properties = new Properties();
		
		properties.load(new FileInputStream("/home/uwe/development/jare_sql_generator.properties"));
		
		String packageName = "com.datamelt.rules.implementation";
		String [] className = properties.getProperty("className").split(",");

		for(int f=0;f<className.length;f++)
		{
			ArrayList<String> statements = generator.createAllMethodSql(packageName, className[f].trim());
			String checkStatement = generator.createCheckSql(packageName,className[f]);
			System.out.println(checkStatement);
			for(int i=0;i<statements.size();i++)
			{
				System.out.println(statements.get(i));
			}
		}
	}
	
	public ArrayList<String> createAllMethodSql(String packageName, String className) throws Exception
	{
		String fullClassName = packageName + "." + className;
		Method []m = ClassUtility.getMethods(fullClassName);
		
		ArrayList<String> statements = new ArrayList<String>();
		for(int i=0;i< m.length;i++)
		{
			Method method = m[i];
			
			// use only the evaluate method of the class
			if(method.getName().equals(GenericCheck.GENERIC_CHECK_METHOD_EVALUATE))
			{
				statements.add(createMethodSql(packageName,className,method));
			}
		}
		return statements;
	}

	public String createCheckSql(String packageName, String className) throws Exception
	{
		String fullClassName = packageName + "." + className;
		Class <?> check = Class.forName(fullClassName);
		
		Annotation [] annotations = check.getAnnotations();
		
		StringBuffer insertStatement = new StringBuffer("insert into check (id,name,description,name_descriptive,package,class,check_single_field) values (");

		insertStatement.append(ClassUtility.getCheckId(fullClassName) + ",");
		insertStatement.append(className + ",");
		
		insertStatement.append(");");
		return insertStatement.toString();

	}
	
	public String createMethodSql(String packageName, String className, Method method) throws Exception
	{
		String fullClassName = packageName + "." + className;
		// get the classes of the parameters to be passed to the method
		Class<?> []parameterClasses = method.getParameterTypes();
		
		StringBuffer insertStatement = new StringBuffer("insert into check_method (check_id,compare,compare_to,note,parameter1,parameter1_explanation,parameter2,parameter2_explanation,parameter3,parameter3_explanation) values (");

		String compare=null;
		String compare_to=null;
		String parameter1=null;
		String parameter2=null;
		String parameter3=null;
		
		// get the names of the parameter classes
		if(parameterClasses.length>=1)
		{
			compare = parameterClasses[0].getSimpleName();
		}
		if(parameterClasses.length>=2)
		{
			compare_to = parameterClasses[1].getSimpleName();
		}
		if(parameterClasses.length>=3)
		{
			parameter1 = parameterClasses[2].getSimpleName();
		}
		if(parameterClasses.length>=4)
		{
			parameter2 = parameterClasses[3].getSimpleName();
		}
		if(parameterClasses.length==5)
		{
			parameter3 = parameterClasses[4].getSimpleName();
		}
		
		insertStatement.append(ClassUtility.getCheckId(fullClassName) + ",");
		insertStatement.append(getValueOrNull(compare) + ",");
		insertStatement.append(getValueOrNull(compare_to) + ",");
		
		// get the annotation from the method
		Annotation [] annotations = method.getAnnotations();
		
		String annotationNote = null;
		String parameter1_explanation = null;
		String parameter2_explanation = null;
		String parameter3_explanation = null;
		
		if(annotations.length>0)
		{
			CheckMethodAnnotation ca = (CheckMethodAnnotation)annotations[0];
			if(ca.note()!=null)
			{
				annotationNote = ca.note();
			}
			if(ca.noteParameter().length>=1)
			{
				parameter1_explanation = ca.noteParameter()[0];
			}
			if(ca.noteParameter().length>=2)
			{
				parameter2_explanation = ca.noteParameter()[1];
			}
			if(ca.noteParameter().length==3)
			{
				parameter3_explanation = ca.noteParameter()[2];
			}
		}
		
		insertStatement.append(getValueOrNull(annotationNote) + ",");
		insertStatement.append(getValueOrNull(parameter1) + ",");
		insertStatement.append(getValueOrNull(parameter1_explanation) + ",");
		insertStatement.append(getValueOrNull(parameter2) + ",");
		insertStatement.append(getValueOrNull(parameter2_explanation) + ",");
		insertStatement.append(getValueOrNull(parameter3) + ",");
		insertStatement.append(getValueOrNull(parameter3_explanation));
		
		insertStatement.append(");");
		return insertStatement.toString();
	}
	
	/**
	 * returns the value in quotes or returns a string representation
	 * of the value null (null embedded in quotes).
	 * 
	 * @param value		a value to evaluate
	 * @return			a quoted String value
	 */
	private static String getValueOrNull(String value)
	{
		String hyphen = "'";
		String nullValue = "null";
		if(value!=null && !value.equals("null"))
		{
			return hyphen + value + hyphen;
		}
		else
		{
			return nullValue;
		}
	}
}
